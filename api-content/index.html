{"posts":[{"title":"AtCoder 做题记录","content":"AtCoderRegularContest186AmodMGame2Difficulty：1042唐完了，不会做打表（大便）题，1≤n×(n−1)2modm≤n1\\le\\frac{n\\times(n-1)}2\\modm\\len1≤2n×(n−1)​modm≤n时Bob，否则Alice。B+1and-1Difficulty：1332我都能场最后数列的状态固定，从前往后模拟，前面有多的就留个tag。EAdjacentGCDDifficulty：2185欧拉函数，数论欧拉函数反演n=\\sum_{d|n}\\varphi(d)\\\\\\gcd(a,b)=\\sum_{d|\\gcd(a,b)}\\varphi(d)=\\sum_{d|a\\andd|b}\\varphi(d)对于本题，每次加入一个aia_iai​后，新增ans+∑j=1i−1gcd⁡(aj,ai)×2j−1ans+\\sum_{j=1}^{i-1}\\gcd(a_j,a_i)\\times2^{j-1}ans+∑j=1i−1​gcd(aj​,ai​)×2j−1的贡献。由于gcd⁡\\gcdgcd的其中一项确定，则可以枚举aia_iai​的因数ddd，添加sumd×φ(d)sum_d\\times\\varphi(d)sumd​×φ(d)的贡献。最后对于每个因数ddd，sumd+=2i−1sum_d+=2^{i-1}sumd​+=2i−1即可。DRandomWalkonTreeDifficulty：2649推式子，期望就是走完nnn条长度为mmm的链。走完一条链的充要条件是走到叶子节点，钦定dep0=0dep_0=0dep0​=0。定义有效点为之前没别走过的点。fif_ifi​表示从深度为iii的有效点走到i+1i+1i+1的有效点期望步数。fi=12+1+fi−1+fi2fi=2+fi−1f_{i}=\\frac12+\\frac{1+f_{i-1}+f_{i}}2\\\\f_i=2+f_{i-1}fi​=21​+21+fi−1​+fi​​fi​=2+fi−1​即有12\\frac1221​的概率直接走到，和先往i−1i-1i−1走再走回来，再到i+1i+1i+1的步数期望。初始化f0f_0f0​与当前有多少条已经走完的链相关，并且如果走到了无效点还要走回来。设可以走到的有效点数为kkk，pip_ipi​表示从深度为iii的点走到i−1i-1i−1的步数期望。ppp实际上在链上走的情况和fff相同，故pi=2+pi+1p_i=2+p_{i+1}pi​=2+pi+1​，初始化pm=1p_m=1pm​=1。f0=kn+(1−kn)×(1+p1+f0)f0=n+(n−k)×p1if_0=\\frac{k}{n}+(1-\\frac{k}{n})\\times(1+p_1+f_0)\\\\f_0=\\frac{n+(n-k)\\timesp_1}if0​=nk​+(1−nk​)×(1+p1​+f0​)f0​=in+(n−k)×p1​​先计算从n−1n-1n−1个叶子回到000号点的贡献，即为(n−1)×∑i=1mpi(n-1)\\times\\sum_{i=1}^mp_i(n−1)×∑i=1m​pi​。再计算从000号点到dep=1dep=1dep=1的有效点后再到叶子节点的贡献和，即为∑i=1n∑j=1mfj\\sum_{i=1}^n\\sum_{j=1}^mf_j∑i=1n​∑j=1m​fj​，时间复杂度为O(n2)O(n^2)O(n2)（注：每次fjf_jfj​都需要重新计算，因为f0f_0f0​的值会变）。观察到fi=2+fi−1f_i=2+f_{i-1}fi​=2+fi−1​的式子非常简单，甚至是等差数列，可以得到通项公式fi=f0+2×(i−1)f_i=f_0+2\\times(i-1)fi​=f0​+2×(i−1)，故∑i=1mfi=∑i=1m(f0+2×(i−1))=m×f0+m×(m−1)\\sum_{i=1}^mf_i=\\sum_{i=1}^m(f_0+2\\times(i-1))=m\\timesf_0+m\\times(m-1)i=1∑m​fi​=i=1∑m​(f0​+2×(i−1))=m×f0​+m×(m−1)优化后就可以O(1)O(1)O(1)求出f0f_0f0​和∑fi\\sumf_i∑fi​了，复杂度为O(nlog⁡2n)O(n\\log_2n)O(nlog2​n)，使用预处理逆元做到O(n)O(n)O(n)，但是我懒了。Codep[m]=1;for(inti=m-1;i;i--)p[i]=imadd(p[i+1],2);intinvn=qpow(n,mod-2);intans=0,sum=0;for(inti=1;i&lt;=m;i++)madd(ans,p[i]);mmul(ans,n-1);for(inti=1;i&lt;=n;i++){intf0=immul(imadd(n,immul(n-i,p[1])),qpow(i,mod-2));madd(ans,immul(m,f0));madd(ans,immul(m,m-1));}AtCoderRegularContest186BTypicalPermutationDescriptorDifficulty：1677赛时差一点写完的计数，唐不难得出当前序列中ppp最小的数的位置，然后从这一点断开后形成两个新区间，两个区间相互独立，只要×(r−lp−l)\\times\\binom{r-l}{p-l}×(p−lr−l​)将数划分到两个区间即可。CBallandBoxDifficulty：2451贪心，博弈按容量从小到大排序，相同容量花费从大到小。最后的状态一定形如ViV_iVi​最大的m−1m-1m−1个会只获得111的贡献，剩余获得ViV_iVi​的贡献，即s=∑i=1k−m+1Vi+m−1−∑i=1kPis=\\sum_{i=1}^{k-m+1}V_i+m-1-\\sum_{i=1}^kP_is=∑i=1k−m+1​Vi​+m−1−∑i=1k​Pi​。对后缀用大根堆维护最小的m−1m-1m−1个ViV_iVi​作为所选的数中最大的m−1m-1m−1个，剩余的选取所有[1,i−1][1,i-1][1,i−1]中(Vi−Pi)(V_i-P_i)(Vi​−Pi​)为正的，求和即可。AUndercluedDifficulty：2511性质，转化好困难。看到01矩阵，尝试给二分图定向。当ai,j=0a_{i,j}=0ai,j​=0时，Li↔RjL_i\\leftrightarrowR_jLi​↔Rj​，当ai,j=1a_{i,j}=1ai,j​=1时，Ri↔LjR_i\\leftrightarrowL_jRi​↔Lj​，则两个矩阵相似即为对于每个点在两个图中的出入度相同。原矩阵上(i,j)(i,j)(i,j)是不动点，当且仅当在二分图中改变图的形态但出入度不变时，上面连的边不变。考虑变一条边的方向后，会继续影响别的点，知道绕回原点，即形成一个简单环后才会结束，则不动点即为二分图上不在简单环上的边。转化后就不困难了，设dpi,j,kdp_{i,j,k}dpi,j,k​表示左部点前iii个点和右部点前jjj个点，形成的环能否覆盖恰好kkk条边。枚举左部点新加uuu个点，右部点新加vvv个点，且这些点形成一个强连通分量。新覆盖成了u×vu\\timesvu×v条边，即uuu个左部点都会和vvv个右部点的连边一一被覆盖。因为是可行性dp，转移可以用bitset，时间复杂度降为O(n6ω)\\mathcalO(\\frac{n^6}\\omega)O(ωn6​)，但不用也能过。AtCoderRegularContest187DManyEasyOptimizationsDifficulty：2880here","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/atcoder-solution/"},{"title":"CP duels","content":"##CF1368ESkiAccidents比较神的构造，被对手10min秒了。看到47\\frac4774​和outi≤2out_i\\le2outi​≤2，然后就应该想到47=2220+21+22\\frac47=\\frac{2^2}{2^0+2^1+2^2}74​=20+21+2222​，尝试将nnn划分为333个集合。感觉比较结论，所以直接说了。将nnn划分成333个无交且并为全集的集合A,B,CA,B,CA,B,C，满足∀a∈A,{∀u→a,u∈C}\\foralla\\inA,\\{\\forallu\\rarra,u\\inC\\}∀a∈A,{∀u→a,u∈C}∀b∈B,{∃u→b,u∈A},{∃u→b,u∈B}\\forallb\\inB,\\{\\existu\\rarrb,u\\inA\\},\\{\\not\\existu\\rarrb,u\\inB\\}∀b∈B,{∃u→b,u∈A},{​∃u→b,u∈B}∀c∈C,{∃u→c,u∈B}\\forallc\\inC,\\{\\existu\\rarrc,u\\inB\\}∀c∈C,{∃u→c,u∈B}分类讨论一下，不难发现A,B,CA,B,CA,B,C交且并为全集。由于∀b∈B,∃a→b\\forallb\\inB,\\exista\\rarrb∀b∈B,∃a→b，∣B∣≤2∣A∣|B|\\le2|A|∣B∣≤2∣A∣，同理，∣B∣≤2∣C∣|B|\\le2|C|∣B∣≤2∣C∣，即4∣A∣≥2∣B∣≥∣C∣4|A|\\ge2|B|\\ge|C|4∣A∣≥2∣B∣≥∣C∣，∣C∣≤47n|C|\\le\\frac47n∣C∣≤74​n。删除CCC中的所有点后AAA的入度都是000，BBB的出度都是000，故最多只有a→ba\\rarrba→b的边，满足条件。因为是DAG，分集合时可以做拓扑排序。复杂度线性。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/cp-duels/"},{"title":"NOIP 犹记","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。前情提要这篇游记是在Day7写的，可能比较暴躁，讲究看吧。不要恶评，看到就删。Day0晚上没要到体锻不爽。Day16点多就起了，7：00出发去考场。要用Sublime，不爽。开T1，好答辩（满脑子循环播放：你不切T1你切什么题，你不切题你打什么比赛）。应该直接贪心是对的，但是也不确定。矛盾后终于开写了，1h左右一遍过大样例了，爽，上个厕所压压惊。T2应该不用矩阵快速幂，直接算就行了。30min写完，一遍过大样例，爽（伏笔才1.5h，放松许多。开始拼暴力，T3是什么鬼，跳了。T4应该是DS，想想想。不会一点，直接拼部分分。T3完全看不懂是在干什么，只会暴力，k=1k=1k=1都不会，rlfl。感觉后面一直在坐牢，连拍子都没上，部分分也不太会打（伏笔估分：100+100+12+36=248100+100+12+36=248100+100+12+36=248。出来了。不出意外，部分分打得太少了，T3好像很多都应该要会，真要学计数了。Day7早上信息会考。下午知道分了，洛谷上没挂分，爽！（伏笔1hlater......好像T2挂了30pts。真的服了，多写了一个=。依照惯例，下面放个代码。sort(a+1,a+n+1);for(inti=1;i&lt;=n;i++)if(a[i].fi==a[i+1].fi&amp;&amp;a[i].se!=a[i+1].se)returnputs(&quot;0&quot;),void();n=unique(a+1,a+n+1)-a-1;解释一下，因为有多测，而for循环中访问到了an+1a_{n+1}an+1​，所以有可能在上组多测中an+1.fi=a_{n+1.fi}=an+1.fi​=当前多测的an.fia_{n.fi}an.fi​，然后就多判了000。但是这概率不应该超级小吗，T≤10T\\le10T≤10能给我挂6个点，我#@!$!Y$!($&amp;(!&amp;)$!@&amp;$^&amp;@!$。但是为什么_log_的如果ans=0ans=0ans=0不为T组询问中的后缀就会错都能通过，CCF负众望。。。烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦听说misakaS组也有这个问题，但是CCF数据没挂。等正式分吧。upd：被骗了，只挂了151515。100+85+16+32=233100+85+16+32=233100+85+16+32=233。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/noip2024/"},{"title":"CSP2024 煤济","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。Day0连续三天飞盘，爽完了。Day1上午打J，应该是最后一场了，弥补去年挂分的遗憾。初赛竟然AK了，直接尝试双AK（初赛+复赛）。T1会。T2会。T3会，上拍。T4不会。。我怎么不会？！#！@#！#！*&amp;@#%……@#rrr怎么这么小，不会有是分层图吧（怎么连续两年T4放分层图）。会了，写写写。写完，跑大样例，2s+。本地机子怎么这么慢！卡常，卡常。然后就卡了1.5h，比赛结束前15min卡过了，爽。出考场，lbw强完了，提前两小时AK，/bx/bx/bx。菇粉：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。下午打S。早起拜锦鲤，rp++！开T1，会了！嗯？T1被秒了？CCF真是越来越会出题了。。。（伏笔）开T2，给一堆式子，这题充满单调性，第一问会了，上二分后求最少有多少个点被所有区间覆盖。这。。。思考一下很可做，AcSaber应该打过，但我都是贺的（后悔ing...）。然后就会了。写写写。卡卡卡。过大样例了，爽！稳一波，先写后面暴力，50+28拿下。这时还有1.5h左右，然后就迎来了全场最迷惑的操作。莫名其妙开始猜一波，T3超级困难，然后为了防止挂大分，然后就开始检查代码了？测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。然后还剩40min，继续无视T3的存在，开始拍T2。写写写，拍拍拍。然后比赛结束都没拍问题，比较爽了。出考场，lbw薄纱我，T3怎么被切爆了？？？（CCF真是越来越会出题了，呼应）简单提一嘴我就会了，我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。菇粉：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。Day¿神秘途径获得J组的民间分数，怎么T4挂了第2个点，布什个门，CCF球球了。S组好像没有挂分。Day¿¿出分日。省流：13:00-&gt;16:00-&gt;17:30，CCF不愧是你。J：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。双AK，双倍满足。S：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。挂分了，但是CCF又挂回来了（不愧是你）。最后放一下S组T3的部分代码，多亏CCF神机，要不然就挂15pts了，我写的是O(n2)O(n^2)O(n2)，下面代码是O(n×maxn)O(n\\timesmaxn)O(n×maxn)的，不能写memset，要for循环清空。constintmaxn=2e5+10;lldp[2][maxn];for(inti=1;i&lt;=n;i++){mems(dp[i&amp;1],0);//DP转移}在线讨一手七级勾。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/csp2024/"},{"title":"光速幂学习笔记","content":"多次询问axmodpa^x\\bmodpaxmodp。选定一个数BBB，预处理出aimodp,i∈[0,B)a^i\\bmodp,i\\in[0,B)aimodp,i∈[0,B)和ai×Bmodp,i∈[1,(p−1)B)a^{i\\timesB}\\bmodp,i\\in[1,\\frac{(p-1)}B)ai×Bmodp,i∈[1,B(p−1)​)，询问时axmodp=a⌊xB⌋×axmodBmodpa^x\\bmodp=a^{\\lfloor\\fracxB\\rfloor}\\timesa^{x\\bmodB}\\bmodpaxmodp=a⌊Bx​⌋×axmodBmodp，取B=pB=\\sqrtpB=p​时可以做到O(p)−O(1)O(\\sqrtp)-O(1)O(p​)−O(1)快速幂。然而O(p)O(\\sqrtp)O(p​)可能还是太慢了，实际上可以做到取一个BBB，复杂度为O(log⁡Bp×B)−O(log⁡Bp)O(\\log_Bp\\timesB)-O(\\log_Bp)O(logB​p×B)−O(logB​p)，后面的log⁡Bp\\log_BplogB​p基本就只是常数了，可以按需求平衡复杂度，其实不太好理解，下面放一份B=32B=32B=32的代码，这应该是比较优的块长了，常数较小。inlinevoidinit(intx){Pow[0][0]=Pow[1][0]=Pow[2][0]=Pow[3][0]=Pow[4][0]=Pow[5][0]=1;for(inti=1;i&lt;S;i++)Pow[0][i]=Pow[0][i-1]*x%mod;intb=immul(Pow[0][S-1],x);for(inti=1;i&lt;S;i++)Pow[1][i]=Pow[1][i-1]*b%mod;b=immul(Pow[1][S-1],b);for(inti=1;i&lt;S;i++)Pow[2][i]=Pow[2][i-1]*b%mod;b=immul(Pow[2][S-1],b);for(inti=1;i&lt;S;i++)Pow[3][i]=Pow[3][i-1]*b%mod;b=immul(Pow[3][S-1],b);for(inti=1;i&lt;S;i++)Pow[4][i]=Pow[4][i-1]*b%mod;b=immul(Pow[4][S-1],b);for(inti=1;i&lt;S;i++)Pow[5][i]=Pow[5][i-1]*b%mod;}inlineintqpow(inty){returnPow[5][(y&gt;&gt;25)]*Pow[4][(y&gt;&gt;20)&amp;(S-1)]%mod*Pow[3][(y&gt;&gt;15)&amp;(S-1)]%mod*Pow[2][(y&gt;&gt;10)&amp;(S-1)]%mod*Pow[1][(y&gt;&gt;5)&amp;(S-1)]%mod*Pow[0][y&amp;(S-1)]%mod;}}POW;实测尽量添加#pragmaunroll(4)实现并行，Pow可以开longlong避免多次int强转。完整代码","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/FastPow/"},{"title":"数学学习笔记","content":"狄利克雷卷积Dirichlet定义其本质是一种运算，可以用∗*∗表示。h(x)=f(x)∗g(x)=∑d∣xf(d)g(xd)=∑ab=xf(a)g(b)h(x)=f(x)*g(x)=\\sum_{d|x}f(d)g(\\frac{x}{d})=\\sum_{ab=x}f(a)g(b)h(x)=f(x)∗g(x)=d∣x∑​f(d)g(dx​)=ab=x∑​f(a)g(b)积性函数f(x)f(x)f(x)满足∀(a,b)=1,f(ab)=f(a)f(b)\\forall(a,b)=1,f(ab)=f(a)f(b)∀(a,b)=1,f(ab)=f(a)f(b)。完全积性函数f(x)f(x)f(x)满足f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)。可以使用线性筛算出积性函数。性质交换律：f∗g=g∗ff*g=g*ff∗g=g∗f。结合律：(f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h)。分配律：(f+g)∗h=f∗h+g∗h(f+g)*h=f*h+g*h(f+g)∗h=f∗h+g∗h。若fff和ggg是积性函数，则f∗gf*gf∗g也是积性函数。若fff是积性函数，则fff的逆元也是积性函数。逆元单位函数ε\\varepsilonε，f∗ε=ff*\\varepsilon=ff∗ε=f。若ggg满足f∗g=εf*g=\\varepsilonf∗g=ε，则称g(x)g(x)g(x)是f(x)f(x)f(x)的逆元。逆元唯一。ps：目前还不太懂这是什么，但好像可以理解为ε(n)={1n=10n=1\\varepsilon(n)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}ε(n)={10​n=1n​=1​。g(x)=ε(x)−∑d∣x,d=1f(d)f(xd)1g(x)=\\dfrac{\\varepsilon(x)-\\sum_{d|x,d\\not=1}f(d)f(\\dfrac{x}{d})}{1}g(x)=1ε(x)−∑d∣x,d​=1​f(d)f(dx​)​莫比乌斯函数Möbius定义式n=p1a1p2a2...pkakμ(n)={1n=10∃i≤k,ai&gt;1(−1)kelsen=p_1^{a_1}p_2^{a_2}...p_k^{a_k}\\\\\\mu(n)=\\begin{cases}1&amp;n=1\\\\0&amp;\\existi\\lek,a_i&gt;1\\\\(-1)^k&amp;else\\end{cases}n=p1a1​​p2a2​​...pkak​​μ(n)=⎩⎪⎨⎪⎧​10(−1)k​n=1∃i≤k,ai​&gt;1else​性质μ(x)\\mu(x)μ(x)是积性函数。∑d∣nμ(d)={1n=10n=1\\sum_{d|n}\\mu(d)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}d∣n∑​μ(d)={10​n=1n​=1​即∑d∣nμ(d)=ε(n),μ∗1=ε\\sum_{d|n}\\mu(d)=\\varepsilon(n),\\mu*1=\\varepsilon∑d∣n​μ(d)=ε(n),μ∗1=ε。在狄利克雷卷积中，莫比乌斯函数是常数函数111的逆元。证明n=p1a1p2a2...pkak,n′=p1p2...pk∵μ(k×a2)=0∴∑d∣nμ(d)=∑d∣n′μ(d)n=p_1^{a_1}p_2^{a_2}...p_k^{a_k},n&#x27;=p_1p_2...p_k\\\\\\because\\mu(k\\timesa^2)=0\\\\\\therefore\\sum_{d|n}\\mu(d)=\\sum_{d|n&#x27;}\\mu(d)n=p1a1​​p2a2​​...pkak​​,n′=p1​p2​...pk​∵μ(k×a2)=0∴d∣n∑​μ(d)=d∣n′∑​μ(d)则现在就是尝试在kkk个互异质数中选择一个集合，若集合大小为奇数，答案-1，否则答案+1。k&gt;1k&gt;1k&gt;1时，∑d∣n′μ(d)=∑i=0k(ki)×(−1)i\\sum_{d|n&#x27;}\\mu(d)=\\sum_{i=0}^k\\binom{k}{i}\\times(-1)^i∑d∣n′​μ(d)=∑i=0k​(ik​)×(−1)i。二项式定理是(a+b)n=∑i=0n(ni)aibn−i(a+b)^n=\\sum_{i=0}^n\\binom{n}{i}a^ib^{n-i}(a+b)n=∑i=0n​(in​)aibn−i，将a=−1,b=1a=-1,b=1a=−1,b=1带入则是(1+(−1))n=∑i=0n(ni)×(−1)i=0(1+(-1))^n=\\sum_{i=0}^n\\binom{n}{i}\\times(-1)^i=0(1+(−1))n=∑i=0n​(in​)×(−1)i=0。故k&gt;1k&gt;1k&gt;1时，∑d∣nμ(d)=0\\sum_{d|n}\\mu(d)=0∑d∣n​μ(d)=0。剩下情况不难自证。ps：以上证明只是本人在初学时的结论，不保证正确，等待未来的我修改或确认。反演结论[gcd⁡(i,j)=1]=∑d∣gcd⁡(i,j)μ(d)[\\gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=d∣gcd(i,j)∑​μ(d)例题「HAOI2011」Problemb求∑i=xn∑j=ym[gcd⁡(i,j)=k],(1≤T,x,y,n,m,k≤105)\\displaystyle{\\sum_{i=x}^n\\sum_{j=y}^m[\\gcd(i,j)=k]},(1\\leT,x,y,n,m,k\\le10^5)i=x∑n​j=y∑m​[gcd(i,j)=k],(1≤T,x,y,n,m,k≤105)。(1)f(a,b,k)=∑i=1a∑j=1b[gcd⁡(i,j)=k]f(a,b,k)=\\sum_{i=1}^a\\sum_{j=1}^b[\\gcd(i,j)=k]\\tag{1}f(a,b,k)=i=1∑a​j=1∑b​[gcd(i,j)=k](1)(2)∑i=xn∑j=ym[gcd⁡(i,j)=k]=f(n,m,k)−f(x−1,m,k)−f(n,y−1,k)+f(x−1,y−1,k)\\sum_{i=x}^n\\sum_{j=y}^m[\\gcd(i,j)=k]=f(n,m,k)-f(x-1,m,k)-f(n,y-1,k)+f(x-1,y-1,k)\\tag{2}i=x∑n​j=y∑m​[gcd(i,j)=k]=f(n,m,k)−f(x−1,m,k)−f(n,y−1,k)+f(x−1,y−1,k)(2)(3)f(a,b,k)=∑i=1⌊ak⌋∑j=1⌊bk⌋[gcd⁡(i,j)=1]f(a,b,k)=\\sum_{i=1}^{\\left\\lfloor\\frac{a}{k}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{b}{k}\\right\\rfloor}[\\gcd(i,j)=1]\\tag{3}f(a,b,k)=i=1∑⌊ka​⌋​j=1∑⌊kb​⌋​[gcd(i,j)=1](3)(4)=∑i=1⌊ak⌋∑j=1⌊bk⌋∑d∣gcd⁡(i,j)μ(d)=\\sum_{i=1}^{\\left\\lfloor\\frac{a}{k}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{b}{k}\\right\\rfloor}\\sum_{d|\\gcd(i,j)}\\mu(d)\\tag{4}=i=1∑⌊ka​⌋​j=1∑⌊kb​⌋​d∣gcd(i,j)∑​μ(d)(4)(5)=∑dμ(d)∑i=1⌊ak⌋[d∣i]∑j=1⌊bk⌋[d∣j]=\\sum_{d}\\mu(d)\\sum_{i=1}^{\\left\\lfloor\\frac{a}{k}\\right\\rfloor}[d|i]\\sum_{j=1}^{\\left\\lfloor\\frac{b}{k}\\right\\rfloor}[d|j]\\tag{5}=d∑​μ(d)i=1∑⌊ka​⌋​[d∣i]j=1∑⌊kb​⌋​[d∣j](5)(6)=∑d=1min⁡(⌊ak⌋,⌊bk⌋)μ(d)⌊⌊ak⌋d⌋⌊⌊bk⌋d⌋=\\sum_{d=1}^{\\min(\\left\\lfloor\\frac{a}{k}\\right\\rfloor,\\left\\lfloor\\frac{b}{k}\\right\\rfloor)}\\mu(d)\\left\\lfloor\\frac{\\left\\lfloor\\frac{a}{k}\\right\\rfloor}d\\right\\rfloor\\left\\lfloor\\frac{\\left\\lfloor\\frac{b}{k}\\right\\rfloor}d\\right\\rfloor\\tag{6}=d=1∑min(⌊ka​⌋,⌊kb​⌋)​μ(d)⌊d⌊ka​⌋​⌋⌊d⌊kb​⌋​⌋(6)(1)(1)(1)到(2)(2)(2)的过程是二维差分，(3)(3)(3)到(4)(4)(4)的过程就是反演结论的使用，(5)(5)(5)到(6)(6)(6)是因为∑i=1⌊ak⌋[d∣i]\\displaystyle\\sum_{i=1}^{\\left\\lfloor\\frac{a}{k}\\right\\rfloor}[d|i]i=1∑⌊ka​⌋​[d∣i]就是[1,⌊ak⌋][1,\\left\\lfloor\\frac{a}{k}\\right\\rfloor][1,⌊ka​⌋]中是ddd的倍数的个数，另一个同理。使用O(V)O(V)O(V)线性筛预处理出μ(i)\\mu(i)μ(i)和∑i=1nμ(i)\\sum_{i=1}^n\\mu(i)∑i=1n​μ(i)，使用整除分块在O(V)O(\\sqrtV)O(V​)算出(6)(6)(6)。总时间复杂度为O(V+∑V)O(V+\\sum\\sqrtV)O(V+∑V​)。阶定义由欧拉定理可知，(a,m)=1(a,m)=1(a,m)=1，aφ(m)≡1(modm)a^{\\varphi(m)}\\equiv1(\\bmodm)aφ(m)≡1(modm)。故存在最小正整数满足an≡1(modm)a^n\\equiv1(\\bmodm)an≡1(modm)，称nnn为aaa模mmm的阶，记作ord⁡m(a)\\operatorname{ord}_m(a)ordm​(a)。性质a,a2...aord⁡m(a)a,a^2...a^{\\operatorname{ord}_m(a)}a,a2...aordm​(a)模mmm两两不同余。若ap≡aq(modm)a^p\\equiva^q(\\bmodm)ap≡aq(modm)，则p≡q(modord⁡m(a))p\\equivq(\\bmod\\operatorname{ord}_m(a))p≡q(modordm​(a))。(a,m)=(b,m)=1ord⁡m(ab)=ord⁡m(a)ord⁡m(b)⇔gcd(ord⁡m(a),ord⁡m(b))=1(a,m)=(b,m)=1\\\\\\operatorname{ord}_m(ab)=\\operatorname{ord}_m(a)\\operatorname{ord}_m(b)\\Leftrightarrowgcd(\\operatorname{ord}_m(a),\\operatorname{ord}_m(b))=1(a,m)=(b,m)=1ordm​(ab)=ordm​(a)ordm​(b)⇔gcd(ordm​(a),ordm​(b))=1原根primitive-root定义若(g,m)=1(g,m)=1(g,m)=1，且ord⁡m(g)=φ(m)\\operatorname{ord}_m(g)=\\varphi(m)ordm​(g)=φ(m)，则称ggg为模mmm的原根。性质对于m≥3,(g,m)=1m\\ge3,(g,m)=1m≥3,(g,m)=1，则ggg是模mmm的原根⇔\\Leftrightarrow⇔对于φ(m)\\varphi(m)φ(m)的每个质因子ppp，都有gφ(m)p≡1(modm)g^{\\frac{\\varphi(m)}{p}}\\not\\equiv1(\\bmodm)gpφ(m)​​≡1(modm)。若mmm有原根，则原根个数为φ(φ(m))\\varphi(\\varphi(m))φ(φ(m))。原根存在定理：一个数mmm存在原根当且仅当m=2,4,pa,2pam=2,4,p^a,2p^am=2,4,pa,2pa，ppp为奇质数。aaa的最小原根大约在a4\\sqrt[4]a4a​，longlong内的都可以暴力枚举。设ggg为nnn的最小原根，则nnn的原根集合S={gs∣(s,φ(n))=1}S=\\{g^s|(s,\\varphi(n))=1\\}S={gs∣(s,φ(n))=1}。部分证明由第1条得，∀pisprimeandp∣φ(n),gφ(n)p=1(modn)\\forall\\text{pisprimeand}p|\\varphi(n),g^{\\frac{\\varphi(n)}{p}}\\not=1(\\bmodn)∀pisprimeandp∣φ(n),gpφ(n)​​=1(modn)。gsφ(n)p=(gφ(n))spg^{s^{\\frac{\\varphi(n)}{p}}}=(g^{\\varphi(n)})^\\frac{s}{p}gspφ(n)​=(gφ(n))ps​，若gcd⁡(s,φ(n))&gt;1\\gcd(s,\\varphi(n))&gt;1gcd(s,φ(n))&gt;1，则有一个ppp使sp\\frac{s}{p}ps​为正整数，由欧拉定理得gφ(n)≡1(modn)g^{\\varphi(n)}\\equiv1(\\bmodn)gφ(n)≡1(modn)，矛盾，故(s,φ(n))=1(s,\\varphi(n))=1(s,φ(n))=1，证明其必要性。Burnside&amp;Pólya定理(1)[X/G]=1∣G∣∑g∈G∣Xg∣[X/G]=\\dfrac{1}{|G|}\\sum_{g\\inG}|X^g|\\tag{1}[X/G]=∣G∣1​g∈G∑​∣Xg∣(1)即本质不同的等价类个数是不动点个数的平均值。∣Xg∣|X^g|∣Xg∣表示XXX在置换ggg下的不动点个数。(2)[X/G]=1∣G∣∑g∈Gmc(g)[X/G]=\\dfrac1{|G|}\\sum_{g\\inG}m^{c(g)}\\tag{2}[X/G]=∣G∣1​g∈G∑​mc(g)(2)c(g)c(g)c(g)表示置换ggg形成了多少个环。因为一个点在置换ggg上成为不定点当且仅当这个点所在的环是同一种颜色，所以对每个环单独染色即可。ps：(1)(1)(1)中的GGG是定义在染色方案上的，即有nmn^mnm种染色方案，(2)(2)(2)中的GGG是定义在nnn个点的轮换上，即有nnn种旋转方式。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/math/"},{"title":"P4897 【模板】最小割树（Gomory-Hu Tree） 题解","content":"题目传送器更爽的阅读体验题意给一个无向连通图，询问两点之间需要割掉多少边权能使两点不连通。做法因为连通性是可传递的，所以可以使用分治。由于无向图两点间最小割===最大流，所以使用网络最大流求最小割。对于当前处理需要处理的点集sss，随意选两个点uuu和vvv跑一次网络最大流，设最大流为maxflowmaxflowmaxflow，则在最小割树上建一条(u,v,maxflow)(u,v,maxflow)(u,v,maxflow)边。设割掉满流的边后uuu能遍历到的点集为s1s1s1，剩下的点集s2=∁ss1s2=\\complement_ss1s2=∁s​s1。往下递归处理s1s1s1和s2s2s2即可。求s1s1s1可以找最后一次dinic的bfs遍历到的点。现在已经建出了最小割树，考虑如何使用。当断掉一条边后，会花费当前边权的代价，将原树树断成两颗新树，这两棵新树上的点两两互相不连通。那对于求(u,v)(u,v)(u,v)的最小割，只要断掉树上(u,lca(u,v))(u,lca(u,v))(u,lca(u,v))和(lca(u,v),v)(lca(u,v),v)(lca(u,v),v)这两条链中最小的一条边即可。可以使用倍增维护边权最小值。ACCode#include&lt;bits/stdc++.h&gt;#definepiipair&lt;int,int&gt;#definepiiipair&lt;int,pii&gt;#defineebemplace_backusingnamespacestd;constintmaxn=1e5+10;constintmaxm=maxn*100;intn,m;structTree{intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}}Tr;namespaceGraph{piiig[maxn];intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}inlinevoidrebuild(){cnt=1;memset(head,0,sizeof(head));for(inti=1;i&lt;=m;i++){add(g[i].first,g[i].second.first,g[i].second.second);add(g[i].second.first,g[i].first,g[i].second.second);}}}usingnamespaceGraph;intS,T;namespaceDINIC{constintinf=0x3f3f3f3f;intd[maxn],now[maxn];queue&lt;int&gt;q;inlineboolbfs(){while(!q.empty())q.pop();memset(d,0x3f,sizeof(d));memcpy(now,head,sizeof(head));d[S]=0;q.push(S);while(!q.empty()){intu=q.front();q.pop();for(inti=head[u];i;i=e[i].nxt){intt=e[i].to;if(d[t]!=inf||!e[i].w)continue;d[t]=d[u]+1;q.push(t);if(t==T)returntrue;}}returnfalse;}intdfs(intu,intflw){if(u==T)returnflw;intres=0;for(inti=now[u];i&amp;&amp;flw;i=e[i].nxt){now[u]=i;intt=e[i].to;if(d[t]!=d[u]+1||!e[i].w)continue;intk=dfs(t,min(e[i].w,flw));if(!k)d[t]=inf;e[i].w-=k;e[i^1].w+=k;res+=k;flw-=k;}returnres;}inlineintdinic(){rebuild();intres=0;while(bfs())res+=dfs(S,inf);returnres;}}usingnamespaceDINIC;namespaceDFS{intw[20][maxn],f[20][maxn],dep[maxn];voiddfs(intu,intfa){dep[u]=dep[f[0][u]=fa]+1;w[0][u]=inf;for(inti=Tr.head[u];i;i=Tr.e[i].nxt){intt=Tr.e[i].to;if(t==fa)continue;dfs(t,u);w[0][t]=Tr.e[i].w;}}inlinevoidinit_LCA(){for(inti=1;i&lt;=19;i++)for(intj=1;j&lt;=n;j++){w[i][j]=min(w[i-1][j],w[i-1][f[i-1][j]]);f[i][j]=f[i-1][f[i-1][j]];}}inlineintLCA(intx,inty){//O(nlogn)-O(logn)倍增intres=inf;if(dep[x]&lt;dep[y])swap(x,y);for(inti=19;~i;i--){if(dep[f[i][x]]&gt;=dep[y]){res=min(res,w[i][x]);x=f[i][x];}}if(x==y)returnres;for(inti=19;~i;i--){if(f[i][x]^f[i][y]){res=min(res,w[i][x]);res=min(res,w[i][y]);x=f[i][x];y=f[i][y];}}res=min(res,w[0][x]);res=min(res,w[0][y]);returnres;}}vector&lt;int&gt;v,v1,v2;voiddivide(intl,intr){v1.clear();v2.clear();if(l&gt;=r)return;S=v[l];T=v[l+1];intres=dinic();Tr.add(S,T,res);Tr.add(T,S,res);for(inti=l;i&lt;=r;i++){if(d[v[i]]!=inf)v1.eb(v[i]);elsev2.eb(v[i]);}for(inti=0;i&lt;v1.size();i++)v[i+l]=v1[i];for(inti=0;i&lt;v2.size();i++)v[i+l+v1.size()]=v2[i];intsiz=v1.size();divide(l,l+siz-1);divide(l+siz,r);}intmain(){scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(inti=1,u,v;i&lt;=m;i++){scanf(&quot;%d%d%d&quot;,&amp;g[i].first,&amp;g[i].second.first,&amp;g[i].second.second);}for(inti=0;i&lt;=n;i++)v.eb(i);divide(0,n);DFS::dfs(1,0);DFS::init_LCA();intq;scanf(&quot;%d&quot;,&amp;q);while(q--){intu,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v);printf(&quot;%d\\n&quot;,DFS::LCA(u,v));}}总结时间复杂度为O(n×D)O(n\\timesD)O(n×D)。O(D)O(D)O(D)是dinic的时间复杂度，理论是O(n2×m)O(n^2\\timesm)O(n2×m)，但实际上小很多。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/p4897-solution/"},{"title":"P10271 漫长悄悄话题解","content":"题目传送器更爽的阅读体验前言为什么都用PAM和子序列自动机，我会二分答案+manacher+Hash。题意自行看题。做法推一下式子即可，preipre_iprei​表示iii的前缀。Rev(lcs(i,j))=LCP(Rev(prei),Rev(prej))Rev(lcs(i,j))=LCP(Rev(pre_i),Rev(pre_j))Rev(lcs(i,j))=LCP(Rev(prei​),Rev(prej​))手模一下样例就能发现其实就是求以iii为中心的回文半径和以jjj为中心的回文半径的LCP\\text{LCP}LCP。显然答案是有二分性的，可以二分答案xxx后将每个位置iii对应的[i−x+1,i][i-x+1,i][i−x+1,i]的哈希值放入map或unordered_map中，只要有相同的就返回true。manacher只需要跑以当前点为中心的回文串即可，不用在相邻两位加入字符。ACCode#include&lt;bits/stdc++.h&gt;#defineullunsignedlonglongusingnamespacestd;constintmaxn=1e6+10,base=31;intn,p[maxn];ullhsh[maxn],bs[maxn];strings;unordered_map&lt;ull,bool&gt;mp;//记录是否出现过的哈希值inlineullHash(intl,intr){returnhsh[r]-hsh[l-1]*bs[r-l+1];}inlineboolcheck(intx){mp.clear();for(inti=1;i&lt;=n;i++){if(p[i]&lt;x)continue;if(mp[Hash(i-x+1,i)])returntrue;mp[Hash(i-x+1,i)]=true;}returnfalse;}intmain(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);cin&gt;&gt;n&gt;&gt;s;s='|'+s+'#';bs[0]=1;for(inti=1;i&lt;=n;i++){hsh[i]=hsh[i-1]*base+(s[i]-'a');bs[i]=bs[i-1]*base;}//manacherfor(inti=1,mid=0,r=0;i&lt;=n;i++){p[i]=i&gt;r?1:min(p[(mid&lt;&lt;1)-i],r-i+1);while(s[i+p[i]]==s[i-p[i]])p[i]++;if(i+p[i]&gt;r){r=i+p[i]-1;mid=i;}}//二分答案intl=1,r=n,ans=0;while(l&lt;=r){intmid=(l+r)&gt;&gt;1;if(check(mid)){ans=mid;l=mid+1;}elser=mid-1;}printf(&quot;%d\\n&quot;,ans);}总结&amp;乱搞时间复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，跑得还挺快。实测不使用哈希，直接将字符串区间放入unordered_map，也就是O(n2×log⁡2n)O(n^2\\times\\log_2n)O(n2×log2​n)也能过，只用300+ms。","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/p10271-solution/"},{"title":"GDOI 2024 游记","content":"今年的第一场正式赛。Day-?作为NOIP都没有正是名额的Joker，获得推荐名额，大喜！Day-?开学就停课，寒假作业还能补，大大喜！Day0上午_maojun_建了模板题大赛，但都不太会，被爆踩了。中午又回东莞了，一个下午貌似都在颓废，根本没有心情复习，希望rp++。晚上cyz的电脑就放在桌子上，教练竟然忘记了收了？？？我们甚至22:30在看去年D1T1。Day16:30就起来了，脑子快萎缩了，和cyz看看网络流板子，零时抱佛脚，希望rp++吧。刚准备出门，cyz就要食便哩。硬是等到7:10才吃早餐。8:00准时进考场，赛时注意事项竟然说不会过滤行首换行，评价是不如nboj。T1：一开始甚至认为答案具有二分性，打完之后甚至能过样例，但过不了ex_data2。有点难受，但可以拿性质A的30pts.感觉D1T1都切不出来有点蠢了。重新构思。1:10发现可以枚举mmodnm\\bmodnmmodn，然后将式子带入后就是类似于∣sthx∣+∣sthy∣+∑≤sth|sth_x|+|sth_y|+\\sum\\lesth∣sthx​∣+∣sthy​∣+∑≤sth，式子里就只有一个未知数为$\\left\\lfloor\\dfrac{m}{n}\\right\\rfloor$。然后只要枚举两个绝对值中的正负，然后爆解未知数就行了，细节超多，但是O(∑n)O(\\sumn)O(∑n)。2:30完成，过大样例了，大大大喜！！！wtcl。T2：切完T1貌似就不太慌了，两个小时就不信打不完暴力。2:45打完暴力，开始写特殊性质。Task7,8貌似比较简单，n=2n=2n=2，只要二分答案，再状压一下就好了。3:00过大样例了。T3：题目好臭啊，看了半天。先打个暴力。Task5,6只用输入nnn，打表找个规律，发现了ans=n!ans=n!ans=n!。打完就差不多了。估分：100+20+24=144pts100+20+24=144pts100+20+24=144pts。出考场了，_maojun_和liangbowenT1差一点，有点抽象。我妈又带我们去吃饭。晚上回来打abc，E好抽象，D题unordered_map没开longlong，数组又开小了，吃了两发答辩RE，太蠢了。还好最后把F切了，涨了小分。打完继续颓废，5=1出了UOrange，rp快爆炸了！Day2T1：题目的图甚至是线段树，思考思考。好像每次操作相当于将区间min由min(ls,rs)min(ls,rs)min(ls,rs)到lslsls。看上去好像可以把特殊性质B给做了。1:10打完了，但过不了大样例，好难受。结果假了，真的蠢。去写暴力和A性质了。2:00写完了，2:30过大样例，又只剩2h了。T2：题目读不懂，先去做T3，结果T3看懂了题目，但看不懂样例解释，又回来了。先打了个暴力，又过不了第三个样例。重新读题，甚至可以同一个地方剪两次，好离谱！3:10打完暴力，开始乱搞。B性质其实都包含m=n−1m=n-1m=n−1，所以关系是确定的，就是保证最后111在所有的前面即可。打表发现ans=1+kn+kans=\\dfrac{1+k}{n+k}ans=n+k1+k​，太爽了，又打出规律了，比赛也只剩10min，检查一手代码。m=0m=0m=0直接输出1。T3：至今不理解样例是怎么做的，来一波玄学。scanf(&quot;%d%d&quot;,&amp;n,&amp;m);while(m--)printf(&quot;%d\\n&quot;,n);估分：40+20+0=60pts40+20+0=60pts40+20+0=60pts。出来后发现甚至T3没有判opt=2了，不能玄学了，大悲。总估分：(100+20+24)+(40+20+0)=204pts(100+20+24)+(40+20+0)=204pts(100+20+24)+(40+20+0)=204pts。除非挂一个4pts4pts4pts的点或不挂分才能上200200200pts。WTCL。Orzyinhee暴切D1T1，D1T2，D2T1。回广州了，正式回归whk了，难受！Day3Yundou估分(80+12+24)+(45+20+0)=181pts(80+12+24)+(45+20+0)=181pts(80+12+24)+(45+20+0)=181pts。D1T1ans初值设成了101210^{12}1012，这波属实小丑了，D1T2不知道为什么二分答案挂了，好像是n=1n=1n=1的忘记判断了。D2T1假解多冲了一个点。希望正式数据D1T1答案小一点吧，D2T1数据水一点。在估一遍吧：([70,100]+12+24)+([40,45]+20+0)=[166,201]([70,100]+12+24)+([40,45]+20+0)=[166,201]([70,100]+12+24)+([40,45]+20+0)=[166,201]。坐等被打脸&amp;爆踩。GDOI2024rp++\\color{red}\\large\\text{GDOI2024rp++}GDOI2024rp++Day6感谢hyx。(70+20+24)+(40+20+0)=174pts(70+20+24)+(40+20+0)=174pts(70+20+24)+(40+20+0)=174pts，只挂了T1的303030pts,难受！没有200+200+200+。最后展示一下T1部分代码。#defineintlonglongintans=1e12;//改成1e18就过了...ans=min(ans,******)；在此发誓，以后代码中包含和答案取min/max的我将按以下形式书写，麻烦各位监督。bool__=1;intans=0;inlinevoidansmn(intx){if(__)ans=x;elseans=min(ans,x);__=false;}","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/gdoi2024/"},{"title":"关于","content":"欢迎来到我的小站呀，很高兴遇见你！🤝🏠关于本站👨‍💻博主是谁⛹兴趣爱好📬联系我呀Abstract","link":"https://yaohaoyou.github.io/AbsMatt.github.io/post/about/"}]}